import{highlightSpecialChars as f,drawSelection as g,lineNumbers as p,EditorView as a,highlightActiveLineGutter as y,highlightActiveLine as w,keymap as c}from"@codemirror/view";export{EditorView,keymap}from"@codemirror/view";import{Compartment as E,EditorState as S}from"@codemirror/state";export{EditorState}from"@codemirror/state";import{syntaxHighlighting as k,defaultHighlightStyle as b,foldGutter as v}from"@codemirror/language";import{history as O,defaultKeymap as C,historyKeymap as l,emacsStyleKeymap as x}from"@codemirror/commands";import{highlightSelectionMatches as L,searchKeymap as K}from"@codemirror/search";import{closeBrackets as T}from"@codemirror/autocomplete";import{oneDark as B}from"@codemirror/theme-one-dark";/**
 * @copyright  (C) 2023 Open Source Matters, Inc. <https://www.joomla.org>
 * @license    GNU General Public License version 2 or later; see LICENSE.txt
 */const u=()=>[f(),O(),g(),k(b,{fallback:!0})],d=async e=>{const t=[],o=[];if(e.mode){const{mode:i}=e,h=e[i]||{};o.push(import(`@codemirror/lang-${e.mode}`).then(n=>{if(i==="php")return import("@codemirror/lang-html").then(({html:m})=>{const s=e.html||{selfClosingTags:!0};t.push(n.php({baseLanguage:m(s).language}))});i==="html"&&(h.selfClosingTags=!0),t.push(n[e.mode](h))}).catch(n=>{console.error(`Cannot create an extension for "${e.mode}" syntax mode.`,n)}))}switch(e.lineNumbers&&t.push(p()),e.lineWrapping&&t.push(a.lineWrapping),e.activeLine&&t.push(y(),w()),e.highlightSelection&&t.push(L()),e.autoCloseBrackets&&t.push(T()),e.foldGutter&&t.push(v()),e.keyMap){case"emacs":t.push(c.of([...x,...l]));break;default:t.push(c.of([...C,...K,...l]));break}const r=new E;return r.$j_name="readOnly",t.push(r.of(S.readOnly.of(!!e.readOnly))),("colorSchemeOs"in document.documentElement.dataset&&window.matchMedia("(prefers-color-scheme: dark)").matches||document.documentElement.dataset.colorScheme==="dark")&&t.push(B),e.customExtensions&&e.customExtensions.length&&e.customExtensions.forEach(i=>{if(i instanceof Function){t.push(i());return}const[h,n]=i;o.push(import(h).then(m=>{n.forEach(s=>{t.push(m[s]())})}))}),Promise.all(o).then(()=>t)};async function G(e,t){const o=[u(),await d(t)],r=new a({doc:e.value,root:t.root||null,extensions:o});return e.parentNode.insertBefore(r.dom,e),e.style.display="none",e.form&&e.form.addEventListener("submit",()=>{e.value=r.state.doc.toString()}),t.width&&(r.dom.style.width=t.width),t.height&&(r.dom.style.height=t.height),r}export{G as createFromTextarea,u as minimalSetup,d as optionsToExtensions};
