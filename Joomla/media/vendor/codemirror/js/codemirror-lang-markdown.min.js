import{EditorSelection as x,countColumn as w,Prec as Q,EditorState as U}from"@codemirror/state";import{keymap as _}from"@codemirror/view";import{syntaxTree as b,LanguageSupport as D,Language as J,indentUnit as Y,defineLanguageFacet as Z,foldNodeProp as N,indentNodeProp as W,languageDataProp as ee,foldService as te,LanguageDescription as F,ParseContext as ne}from"@codemirror/language";import{CompletionContext as re}from"@codemirror/autocomplete";import{MarkdownParser as oe,parseCode as le,parser as ie,GFM as se,Subscript as fe,Superscript as me,Emoji as ae}from"@lezer/markdown";import{htmlCompletionSource as ue,html as ce}from"@codemirror/lang-html";import{NodeProp as de}from"@lezer/common";const O=Z({commentTokens:{block:{open:"<!--",close:"-->"}}}),q=new de,$=ie.configure({props:[N.add(e=>!e.is("Block")||e.is("Document")||I(e)!=null?void 0:(l,r)=>({from:r.doc.lineAt(l.from).to,to:l.to})),q.add(I),W.add({Document:()=>null}),ee.add({Document:O})]});function I(e){let l=/^(?:ATX|Setext)Heading(\d)$/.exec(e.name);return l?+l[1]:void 0}function pe(e,l){let r=e;for(;;){let t=r.nextSibling,n;if(!t||(n=I(t.type))!=null&&n<=l)break;r=t}return r.to}const he=te.of((e,l,r)=>{for(let t=b(e).resolveInner(r,-1);t&&!(t.from<l);t=t.parent){let n=t.type.prop(q);if(n==null)continue;let i=pe(t,n);if(i>r)return{from:r,to:i}}return null});function y(e){return new J(O,e,[he],"markdown")}const H=y($),ge=$.configure([se,fe,me,ae,{props:[N.add({Table:(e,l)=>({from:l.doc.lineAt(e.from).to,to:e.to})})]}]),v=y(ge);function ke(e,l){return r=>{if(r&&e){let t=null;if(r=/\S*/.exec(r)[0],typeof e=="function"?t=e(r):t=F.matchLanguageName(e,r,!0),t instanceof F)return t.support?t.support.language.parser:ne.getSkippingParser(t.load());if(t)return t.parser}return l?l.parser:null}}class A{constructor(l,r,t,n,i,f,a){this.node=l,this.from=r,this.to=t,this.spaceBefore=n,this.spaceAfter=i,this.type=f,this.item=a}blank(l,r=!0){let t=this.spaceBefore+(this.node.name=="Blockquote"?">":"");if(l!=null){for(;t.length<l;)t+=" ";return t}else{for(let n=this.to-this.from-t.length-this.spaceAfter.length;n>0;n--)t+=" ";return t+(r?this.spaceAfter:"")}}marker(l,r){let t=this.node.name=="OrderedList"?String(+X(this.item,l)[2]+r):"";return this.spaceBefore+t+this.type+this.spaceAfter}}function R(e,l){let r=[];for(let n=e;n&&n.name!="Document";n=n.parent)(n.name=="ListItem"||n.name=="Blockquote"||n.name=="FencedCode")&&r.push(n);let t=[];for(let n=r.length-1;n>=0;n--){let i=r[n],f,a=l.lineAt(i.from),o=i.from-a.from;if(i.name=="FencedCode")t.push(new A(i,o,o,"","","",null));else if(i.name=="Blockquote"&&(f=/^ *>( ?)/.exec(a.text.slice(o))))t.push(new A(i,o,o+f[0].length,"",f[1],">",null));else if(i.name=="ListItem"&&i.parent.name=="OrderedList"&&(f=/^( *)\d+([.)])( *)/.exec(a.text.slice(o)))){let m=f[3],s=f[0].length;m.length>=4&&(m=m.slice(0,m.length-4),s-=4),t.push(new A(i.parent,o,o+s,f[1],m,f[2],i))}else if(i.name=="ListItem"&&i.parent.name=="BulletList"&&(f=/^( *)([-+*])( {1,4}\[[ xX]\])?( +)/.exec(a.text.slice(o)))){let m=f[4],s=f[0].length;m.length>4&&(m=m.slice(0,m.length-4),s-=4);let d=f[2];f[3]&&(d+=f[3].replace(/[xX]/," ")),t.push(new A(i.parent,o,o+s,f[1],m,d,i))}}return t}function X(e,l){return/^(\s*)(\d+)(?=[.)])/.exec(l.sliceString(e.from,e.from+10))}function P(e,l,r,t=0){for(let n=-1,i=e;;){if(i.name=="ListItem"){let a=X(i,l),o=+a[2];if(n>=0){if(o!=n+1)return;r.push({from:i.from+a[1].length,to:i.from+a[0].length,insert:String(n+2+t)})}n=o}let f=i.nextSibling;if(!f)break;i=f}}function T(e,l){let r=/^[ \t]*/.exec(e)[0].length;if(!r||l.facet(Y)!="	")return e;let t=w(e,4,r),n="";for(let i=t;i>0;)i>=4?(n+="	",i-=4):(n+=" ",i--);return n+e.slice(r)}const K=({state:e,dispatch:l})=>{let r=b(e),{doc:t}=e,n=null,i=e.changeByRange(f=>{if(!f.empty||!v.isActiveAt(e,f.from))return n={range:f};let a=f.from,o=t.lineAt(a),m=R(r.resolveInner(a,-1),t);for(;m.length&&m[m.length-1].from>a-o.from;)m.pop();if(!m.length)return n={range:f};let s=m[m.length-1];if(s.to-s.spaceAfter.length>a-o.from)return n={range:f};let d=a>=s.to-s.spaceAfter.length&&!/\S/.test(o.text.slice(s.to));if(s.item&&d){let c=s.node.firstChild,h=s.node.getChild("ListItem","ListItem");if(c.to>=a||h&&h.to<a||o.from>0&&!/[^\s>]/.test(t.lineAt(o.from-1).text)){let u=m.length>1?m[m.length-2]:null,C,B="";u&&u.item?(C=o.from+u.from,B=u.marker(t,1)):C=o.from+(u?u.to:0);let S=[{from:C,to:a,insert:B}];return s.node.name=="OrderedList"&&P(s.item,t,S,-2),u&&u.node.name=="OrderedList"&&P(u.item,t,S),{range:x.cursor(C+B.length),changes:S}}else{let u=j(m,e,o);return{range:x.cursor(a+u.length+1),changes:{from:o.from,insert:u+e.lineBreak}}}}if(s.node.name=="Blockquote"&&d&&o.from){let c=t.lineAt(o.from-1),h=/>\s*$/.exec(c.text);if(h&&h.index==s.from){let u=e.changes([{from:c.from+h.index,to:c.to},{from:o.from+s.from,to:o.to}]);return{range:f.map(u),changes:u}}}let p=[];s.node.name=="OrderedList"&&P(s.item,t,p);let k=s.item&&s.item.from<o.from,g="";if(!k||/^[\s\d.)\-+*>]*/.exec(o.text)[0].length>=s.to)for(let c=0,h=m.length-1;c<=h;c++)g+=c==h&&!k?m[c].marker(t,1):m[c].blank(c<h?w(o.text,4,m[c+1].from)-g.length:null);let L=a;for(;L>o.from&&/\s/.test(o.text.charAt(L-o.from-1));)L--;return g=T(g,e),xe(s.node,e.doc)&&(g=j(m,e,o)+e.lineBreak+g),p.push({from:L,to:a,insert:e.lineBreak+g}),{range:x.cursor(L+g.length+1),changes:p}});return n?!1:(l(e.update(i,{scrollIntoView:!0,userEvent:"input"})),!0)};function V(e){return e.name=="QuoteMark"||e.name=="ListMark"}function xe(e,l){if(e.name!="OrderedList"&&e.name!="BulletList")return!1;let r=e.firstChild,t=e.getChild("ListItem","ListItem");if(!t)return!1;let n=l.lineAt(r.to),i=l.lineAt(t.from),f=/^[\s>]*$/.test(n.text);return n.number+(f?0:1)<i.number}function j(e,l,r){let t="";for(let n=0,i=e.length-2;n<=i;n++)t+=e[n].blank(n<i?w(r.text,4,e[n+1].from)-t.length:null,n<i);return T(t,l)}function Le(e,l){let r=e.resolveInner(l,-1),t=l;V(r)&&(t=r.from,r=r.parent);for(let n;n=r.childBefore(t);)if(V(n))t=n.from;else if(n.name=="OrderedList"||n.name=="BulletList")r=n.lastChild,t=r.to;else break;return r}const z=({state:e,dispatch:l})=>{let r=b(e),t=null,n=e.changeByRange(i=>{let f=i.from,{doc:a}=e;if(i.empty&&v.isActiveAt(e,i.from)){let o=a.lineAt(f),m=R(Le(r,f),a);if(m.length){let s=m[m.length-1],d=s.to-s.spaceAfter.length+(s.spaceAfter?1:0);if(f-o.from>d&&!/\S/.test(o.text.slice(d,f-o.from)))return{range:x.cursor(o.from+d),changes:{from:o.from+d,to:f}};if(f-o.from==d&&(!s.item||o.from<=s.item.from||!/\S/.test(o.text.slice(0,s.to)))){let p=o.from+s.from;if(s.item&&s.node.from<s.item.from&&/\S/.test(o.text.slice(s.from,s.to))){let k=s.blank(w(o.text,4,s.to)-w(o.text,4,s.from));return p==o.from&&(k=T(k,e)),{range:x.cursor(p+k.length),changes:{from:p,to:o.from+s.to,insert:k}}}if(p<f)return{range:x.cursor(p),changes:{from:p,to:f}}}}}return t={range:i}});return t?!1:(l(e.update(n,{scrollIntoView:!0,userEvent:"delete"})),!0)},G=[{key:"Enter",run:K},{key:"Backspace",run:z}],M=ce({matchClosingTags:!1});function we(e={}){let{codeLanguages:l,defaultCodeLanguage:r,addKeymap:t=!0,base:{parser:n}=H,completeHTMLTags:i=!0}=e;if(!(n instanceof oe))throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");let f=e.extensions?[e.extensions]:[],a=[M.support],o;r instanceof D?(a.push(r.support),o=r.language):r&&(o=r);let m=l||o?ke(l,o):void 0;f.push(le({codeParser:m,htmlParser:M.language.parser})),t&&a.push(Q.high(_.of(G)));let s=y(n.configure(f));return i&&a.push(s.data.of({autocomplete:Ce})),new D(s,a)}function Ce(e){let{state:l,pos:r}=e,t=/<[:\-\.\w\u00b7-\uffff]*$/.exec(l.sliceDoc(r-25,r));if(!t)return null;let n=b(l).resolveInner(r,-1);for(;n&&!n.type.isTop;){if(n.name=="CodeBlock"||n.name=="FencedCode"||n.name=="ProcessingInstructionBlock"||n.name=="CommentBlock"||n.name=="Link"||n.name=="Image")return null;n=n.parent}return{from:r-t[0].length,to:r,options:be(),validFor:/^<[:\-\.\w\u00b7-\uffff]*$/}}let E=null;function be(){if(E)return E;let e=ue(new re(U.create({extensions:M}),0,!0));return E=e?e.options:[]}export{H as commonmarkLanguage,z as deleteMarkupBackward,K as insertNewlineContinueMarkup,we as markdown,G as markdownKeymap,v as markdownLanguage};
